# Cloud Infrastructure and Deployment

## Overview

Modern stock exchanges and brokerages increasingly leverage cloud infrastructure for scalability, global reach, disaster recovery, and cost optimization. However, the ultra-low latency requirements of trading systems, regulatory constraints, and security concerns require careful hybrid cloud architectures combining on-premises, co-location, and cloud components.

## Cloud Provider Selection and Multi-Cloud Strategy

### Primary Cloud Provider Selection
Choosing the right cloud provider involves evaluating multiple factors. AWS offers the broadest service portfolio with 30+ regions, mature services, extensive third-party integrations, largest market share providing ecosystem benefits, and proven financial services customers. Azure provides excellent integration with Microsoft stack, strong compliance certifications, hybrid cloud capabilities with Azure Stack, competitive pricing, and growing financial services presence. GCP excels in big data and machine learning, Kubernetes native environment, global network infrastructure, innovative services like Spanner, and competitive pricing for compute. Selection criteria include: region availability near major exchanges, financial services compliance certifications (SOC 2, PCI-DSS, ISO 27001), performance benchmarks for latency-sensitive workloads, cost modeling for expected usage, vendor stability and roadmap, existing enterprise agreements, skills availability in workforce.

### Multi-Cloud Architecture
Strategic use of multiple cloud providers reduces risk and optimizes capabilities. Active-active multi-cloud deploys trading platform across AWS and Azure simultaneously with traffic splitting, cross-cloud data replication, unified management plane, and cloud-agnostic application design. Best-of-breed approach uses each cloud's strengths: AWS for core infrastructure and broad services, Azure for Microsoft integration and hybrid scenarios, GCP for analytics and machine learning. Disaster recovery multi-cloud runs production in one cloud with DR in another, cost-effective DR setup, testing cutover procedures quarterly, and accepting higher RTO. Challenges include: increased complexity in management, data transfer costs between clouds, different service APIs requiring abstraction, skills needed for multiple platforms, potential for configuration drift, cross-cloud networking complexity.

### Hybrid Cloud Strategy
Combination of on-premises, co-location, and cloud infrastructure. Critical low-latency components remain on-premises or co-located: matching engine (< 1ms latency requirement), high-frequency trading systems, exchange direct connections, real-time risk systems. Cloud handles scalable workloads: market data distribution (global CDN), historical data analysis, reporting and analytics, web and mobile applications, development and testing environments, disaster recovery site. Connectivity between environments uses: dedicated connections (AWS Direct Connect, Azure ExpressRoute), encrypted VPN tunnels, SD-WAN for branch offices, private WAN for trading desks. Data sovereignty addressed through: geo-fencing (data stays in required jurisdiction), encryption with on-premises key management, contractual terms with cloud provider, regulatory approval of cloud usage.

## Compute Services

### Virtual Machines
Foundation of cloud compute for traditional applications. Instance types for different workloads: compute-optimized (C6i, C6gn) for order processing and matching, memory-optimized (R6i, X2iedn) for in-memory databases and caching, general-purpose (M6i) for application servers, GPU instances (P4d) for machine learning models in risk analytics. Instance sizing considerations: right-sizing to avoid waste, burstable instances for variable loads, reserved instances for steady-state (40-60% discount), spot instances for fault-tolerant batch jobs (up to 90% discount), savings plans for flexibility. Auto-scaling policies: target CPU utilization (e.g., 70%), schedule-based (scale up before market open), predictive scaling using ML, scaling cooldown periods to avoid thrashing, minimum instances for availability.

### Container Services
Modern microservices deployment using containers. Kubernetes (EKS, AKS, GKE) provides: declarative configuration, self-healing (restart failed pods), auto-scaling (horizontal pod autoscaler), rolling updates with zero downtime, service mesh integration (Istio, Linkerd), multi-tenancy with namespaces. Deployment patterns: blue-green (two full environments, instant rollback), canary (gradual rollout to subset), rolling update (replace pods incrementally), A/B testing (split traffic for testing). Resource management: CPU and memory requests (guaranteed resources), limits (maximum allowed), quality of service classes (guaranteed, burstable, best-effort), node affinity (control pod placement), pod disruption budgets (availability during maintenance).

### Serverless Compute
Event-driven functions for specific use cases. AWS Lambda, Azure Functions, Google Cloud Functions handle: event processing (Kafka message handling, S3 object processing), API backends (REST endpoints), scheduled jobs (nightly reconciliation), data transformation (ETL pipelines), webhook handlers. Limitations for trading systems: cold start latency (100ms-1s unacceptable for order path), limited execution time (15 minutes), no persistent connections, stateless execution model. Appropriate serverless use cases: historical data queries, report generation, notification distribution, reference data updates, non-critical workflows.

### Bare Metal Instances
Cloud-hosted physical servers for performance-critical workloads. Benefits: no virtualization overhead, consistent performance, physical isolation, direct hardware access, bring your own license. Use cases: high-frequency trading nodes, in-memory databases (SAP HANA), encryption workloads benefiting from AES-NI, compliance requirements for physical isolation. Providers: AWS i3.metal and c5n.metal, Azure Dedicated Host, GCP sole-tenant nodes. Considerations: higher cost than VMs, less flexibility (can't resize), longer provisioning time, manual or custom scaling.

## Storage Services

### Block Storage
High-performance disks for databases and applications. EBS (AWS), Managed Disks (Azure), Persistent Disks (GCP) provide: multiple volume types (SSD for databases, HDD for archives), snapshots for backup, encryption at rest, replication within availability zone, volume sizing up to 64TB. Performance tiers: io2 Block Express (max 256K IOPS, 4000 MB/s throughput) for trading databases, gp3 (balanced cost and performance) for general applications, st1 (throughput-optimized HDD) for data warehousing, sc1 (cold HDD) for infrequent access. IOPS provisioning: calculate IOPS needs from workload (order processing needs high IOPS), provision appropriately to avoid throttling, monitor actual usage, adjust provisioning.

### Object Storage
Scalable storage for unstructured data. S3 (AWS), Blob Storage (Azure), Cloud Storage (GCP) handle: market data archives, trade blotter backups, compliance documents, log files, static assets for web. Storage classes optimize cost: Standard (frequent access, millisecond latency), Infrequent Access (monthly access, cheaper), Glacier (archival, minutes to hours retrieval), Deep Archive (long-term, 12 hour retrieval). Lifecycle policies automate transitions: move to IA after 30 days, move to Glacier after 90 days, delete after 7 years. Object versioning maintains history: all versions retained, ability to restore previous version, MFA delete for protection, version expiration to limit growth.

### File Storage
Shared filesystem for applications requiring POSIX. EFS (AWS), Azure Files, Filestore (GCP) provide: NFSv4 protocol, shared across multiple instances, elastic capacity, encryption, concurrent access. Use cases: shared configuration files, application binaries across instances, user home directories, content management systems, legacy applications expecting filesystem. Performance modes: General Purpose (latency-optimized, most workloads), Max I/O (higher aggregate throughput, big data), throughput modes (bursting vs provisioned). Considerations: higher latency than block storage, costlier than object storage, performance depends on size (larger = more throughput).

### Database Storage
Managed database services with built-in storage. RDS, Aurora, Cosmos DB, Cloud SQL include: automated backups, point-in-time recovery, storage auto-scaling, read replicas for scaling reads, multi-AZ for high availability. Storage types: General Purpose SSD (gp3 for balanced workload), Provisioned IOPS (io1/io2 for high performance), Aurora storage (auto-scaling, 6-way replication). Capacity planning: estimate growth rate, set auto-scaling thresholds, monitor storage metrics, plan for peak (quarter-end, month-end), compression to reduce storage.

## Networking Architecture

### Virtual Private Cloud
Isolated network environment in cloud. VPC design: CIDR range planning (avoid overlap with on-premises), subnet segmentation (public, private, database), multiple availability zones (high availability), reserved IP addresses (AWS reserves 5 per subnet). Routing tables: public subnets route to internet gateway, private subnets route through NAT gateway, database subnets no internet access, custom routes for VPN and Direct Connect. Network ACLs: stateless firewall at subnet level, default allow all (then restrict), rules evaluated in order, separate inbound and outbound rules. Security groups: stateful firewall at instance level, default deny all (then allow), can reference other security groups, separate rules by role (web, app, database).

### Load Balancing
Distribute traffic across multiple instances. Application Load Balancer (Layer 7): HTTP/HTTPS traffic, path-based routing, host-based routing, WebSocket support, SSL termination, request routing to microservices. Network Load Balancer (Layer 4): TCP/UDP traffic, ultra-low latency (microseconds), static IP addresses, preserve source IP, millions of requests per second. Global load balancing: geographic routing (route to nearest region), health checks (remove unhealthy backends), failover (automatic to healthy region), DDoS protection, CDN integration. Health checks: endpoint path, interval (30 seconds), timeout (5 seconds), healthy threshold (2 consecutive successes), unhealthy threshold (2 consecutive failures).

### Content Delivery Network
Edge caching for global low-latency access. CloudFront (AWS), Azure CDN, Cloud CDN (GCP) provide: 200+ edge locations worldwide, HTTPS support, custom SSL certificates, origin failover, compression. Use cases: market data API (cache Level 1 data), historical data queries (cache common requests), web assets (JavaScript, CSS, images), mobile app assets, software downloads. Cache configuration: TTL (time to live) per object type, cache key (URL, query string, headers), invalidation (purge outdated content), origin shield (reduce origin load). Performance: cache hit ratio target >85%, edge location selection (nearest to users), connection pooling to origin, compression (gzip, brotli).

### Private Connectivity
Dedicated connections bypassing public internet. AWS Direct Connect, Azure ExpressRoute, Google Cloud Interconnect offer: consistent network performance, reduced bandwidth costs for high volume, private connectivity to VPC, speeds from 1 Gbps to 100 Gbps. Setup: order circuit from network provider, provision in cloud console, configure BGP peering, test connectivity, implement redundancy (multiple circuits). Virtual interfaces: private VIF (access VPC), public VIF (access public services like S3), transit VIF (access multiple VPCs through transit gateway). SLA: 99.95% uptime for dedicated connection, monitor connection status, automatic failover to VPN, diverse paths for redundancy.

### Service Mesh
Microservices communication management. Istio, Linkerd, AWS App Mesh provide: service discovery (automatic endpoint detection), load balancing (client-side, intelligent algorithms), circuit breaking (prevent cascade failures), retry logic (automatic with exponential backoff), timeouts (prevent hanging), mutual TLS (encrypt service-to-service), observability (distributed tracing, metrics). Traffic management: canary deployment (route % to new version), A/B testing (route based on headers), traffic mirroring (copy production traffic to test), fault injection (test resilience). Security: authentication (verify service identity), authorization (RBAC between services), encryption (automatic mTLS), audit logging (who called what).

## High Availability and Disaster Recovery

### Multi-Region Architecture
Geographic redundancy for disaster recovery and global presence. Region pairs: US-East primary with US-West DR, Europe region for GDPR compliance, Asia-Pacific for low latency to Asian markets, minimum two regions for compliance. Data replication: synchronous within region (zero RPO), asynchronous cross-region (seconds RPO), database native replication (Aurora Global Database, Cosmos DB), storage replication (S3 Cross-Region Replication, GRS). Traffic management: Route 53 health checks and failover, GeoDNS routing to nearest region, automatic failover on region failure, manual failover for planned maintenance. Cost optimization: run scaled-down in DR region (scale up on failover), use cheaper storage tiers in DR, reserved instances only in primary, snapshot-based recovery for non-critical.

### Availability Zones
Physical separation within region for high availability. AZ characteristics: separate data centers (distinct facilities), independent power and cooling, low-latency interconnect (< 2ms), physically separated (different flood plains, separate utilities). Multi-AZ deployment: application servers across 3 AZs, database primary in AZ-A with standby in AZ-B, automatic failover in seconds, load balancer distributes across AZs. Zone failure handling: health checks detect failure, traffic routed to healthy AZs, auto-scaling replaces capacity, database fails over automatically, monitoring alerts operators. Best practices: always use at least 2 AZs, 3 AZs for critical systems, balance capacity evenly, avoid AZ affinity in code, test AZ failure scenarios.

### Backup and Recovery
Comprehensive backup strategy ensuring data protection. Backup types: full backup (weekly, complete copy), incremental backup (daily, changes since last), continuous backup (transaction logs), snapshots (storage-level), cross-region copy (DR protection). Backup retention: operational (30 days online), compliance (7 years archive), legal hold (indefinite), deletion after retention. Recovery procedures: point-in-time recovery (restore to specific timestamp), item-level recovery (single record or file), full system recovery (entire environment), cross-region recovery (DR invocation). Backup testing: monthly restore test (verify backups work), quarterly DR drill (full recovery), document recovery time (measure RTO), automated testing (continuous validation).

### Chaos Engineering
Proactive failure testing to improve resilience. Failure injection: instance termination (random instance shutdown), network latency (inject 500ms delay), network partition (split availability zones), resource exhaustion (CPU or memory stress), dependency failure (simulate database down), region failure (entire region unavailable). Tools: AWS Fault Injection Simulator, Chaos Monkey (Netflix), Gremlin, custom scripts. Testing approach: start small (single instance), gradually increase (multiple instances, then AZ), eventually full (region failure), always have kill switch (abort if issues), test in non-production first (staging environment), eventually test production (with controls). Metrics to monitor: error rates, latency, throughput, user impact, recovery time. Learning: identify weak points, improve architecture, update runbooks, train team.

## Cost Optimization

### Resource Right-Sizing
Match resources to actual needs. Analysis: review CloudWatch metrics (CPU, memory, network), identify underutilized resources (< 40% usage), identify oversized (consistently low utilization), analyze patterns (time-of-day, day-of-week). Actions: downsize instances (larger to smaller type), rightsize (CPU-optimized to memory-optimized), consolidate (combine workloads), decommission (unused resources), schedule (stop during off-hours). Tools: AWS Compute Optimizer, Azure Advisor, GCP Recommender, third-party (CloudHealth, Spot.io). Review frequency: monthly for optimization, quarterly for trends, continuous monitoring for anomalies.

### Reserved Capacity and Savings Plans
Commit to usage for discounts. Reserved Instances: 1 or 3 year terms, upfront payment options (all, partial, none), 40-60% discount vs on-demand, regional or zonal, can modify or sell unused. Savings Plans: commit to compute spend ($/hour), more flexible than RIs (any instance family, region, OS), 1 or 3 year terms, EC2, Fargate, Lambda eligible. Strategy: analyze steady-state usage (run 24/7), start with 1-year (less commitment), apply to production only, use on-demand for variable, combine RI and Savings Plans. Monitoring: track utilization (are RIs used), coverage (how much spend is covered), rightsizing (reservations match actual), renewal planning (don't auto-renew without analysis).

### Spot and Preemptible Instances
Deeply discounted spare capacity for interruptible workloads. Discount: up to 90% off on-demand pricing. Use cases: batch processing (data analysis, risk calculations), big data (Spark, Hadoop clusters), CI/CD (build and test environments), containerized workloads (stateless microservices), rendering (video encoding, image processing). Interruption handling: 2-minute warning (CloudWatch event or metadata), checkpoint progress (save state), graceful shutdown (close connections), requeue work (dead letter queue), retry logic (automatic restart). Mixed fleet: combine on-demand (guaranteed capacity), spot (cost savings), reserved (discount on base), auto-scaling across types. Spot Fleet: diversify (multiple instance types), allocation strategy (lowest price, capacity optimized), maintain capacity (replace interrupted instances).

### Storage Lifecycle Management
Automatically transition data to cheaper tiers. Lifecycle policies: immediate (Intelligent-Tiering, auto-optimization), 30 days (Standard to Standard-IA), 90 days (IA to Glacier), 365 days (Glacier to Deep Archive), 7 years (delete per compliance). Cost comparison: Standard ($0.023/GB), Standard-IA ($0.0125/GB), Glacier ($0.004/GB), Deep Archive ($0.00099/GB). Retrieval costs: Standard (free), IA ($0.01/GB), Glacier ($0.02-0.03/GB), Deep Archive ($0.02/GB). Retrieval times: Standard (instant), IA (instant), Glacier (minutes to hours), Deep Archive (12 hours). Optimization: analyze access patterns, set appropriate policies, monitor transitions, balance storage cost vs retrieval needs, compress before archiving.

### Monitoring and Cost Allocation
Visibility and accountability for cloud spend. Tagging strategy: environment (prod, staging, dev), application (trading, risk, reporting), cost center (department code), owner (team or individual), project (initiative or feature). Cost allocation: tag-based reports, split shared resources, showback (report costs), chargeback (bill departments), budgets and alerts. Tools: AWS Cost Explorer, Azure Cost Management, GCP Cost Management, third-party (CloudCheckr, Cloudability, Apptio). Dashboards: total spend trending, cost by service, cost by environment, top spending resources, budget vs actual. Optimization process: weekly reviews (identify anomalies), monthly reporting (to stakeholders), quarterly planning (forecast and budget), continuous improvement (rightsizing, reservations).

## Infrastructure as Code

### Terraform
Cloud-agnostic infrastructure provisioning. Benefits: declarative syntax (describe desired state), state management (track current state), plan and apply workflow (preview changes), modules (reusable components), provider ecosystem (all major clouds). Structure: root module (main configuration), child modules (reusable infrastructure patterns), remote state (S3 backend with locking), workspaces (separate environments), variable files (per-environment configuration). Workflow: write configuration (HCL), initialize (download providers), plan (preview changes), apply (create resources), destroy (cleanup). Best practices: version control (Git), peer review (pull requests), CI/CD integration (automated apply), state locking (prevent concurrent modifications), output values (pass between modules), sensitive data management (Vault integration).

### CloudFormation
AWS-native infrastructure as code. Templates: JSON or YAML, resources (what to create), parameters (inputs), outputs (information to export), mappings (conditional values), conditions (optional resources). Stack operations: create (initial deployment), update (modify resources), delete (cleanup), change sets (preview updates), drift detection (detect manual changes). Advanced features: nested stacks (composition), stack sets (multi-account/region), custom resources (Lambda-backed), macros (template transformation), registry (third-party resources). Best practices: validate templates (cfn-lint), test locally (LocalStack), modular design (nested stacks), parameterize (environment-specific values), version control (Git), automated deployment (CodePipeline).

### ARM Templates and Bicep
Azure infrastructure provisioning. ARM templates: JSON-based (verbose), declarative, idempotent, complete mode (delete unlisted resources), incremental mode (add or update only). Bicep: simplified syntax (easier than ARM JSON), transpiles to ARM, IntelliSense support, modules (reusable), resource dependencies (automatic). Deployment: resource groups (boundary for resources), subscription level (create resource groups), management group level (policies), tenant level (rare). What-if operation: preview changes before deployment, validate templates, understand impact, approve in pipelines. Best practices: separate files per environment, use parameters file, output values for dependencies, link templates (master calling children), CI/CD integration (Azure DevOps, GitHub Actions).

### Kubernetes Manifests
Declarative configuration for Kubernetes resources. Manifest types: Deployment (app workload), Service (networking), ConfigMap (configuration), Secret (sensitive data), Ingress (HTTP routing), PersistentVolumeClaim (storage), ServiceAccount (identity), NetworkPolicy (firewall rules). GitOps: store manifests in Git, ArgoCD or Flux for sync, pull-based deployment, drift detection, automatic rollback, full audit trail. Helm: package manager for Kubernetes, charts (templated manifests), values files (environment-specific), chart repository (share charts), dependencies (compose charts). Kustomize: overlay-based customization, base (common config), overlays (environment-specific changes), patches (modify resources), generators (create ConfigMaps/Secrets), native kubectl support.

---

**Document Version**: 1.0  
**Last Updated**: January 17, 2026  
**Status**: Complete
